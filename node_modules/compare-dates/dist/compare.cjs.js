'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isValidDate = function (input) {
    return input instanceof Date && !isNaN(input.getTime());
};

const aliases = {};

function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

addUnitAlias('month', 'M');
addUnitAlias('year', 'y');
addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');
addUnitAlias('quarter', 'Q');
addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');
addUnitAlias('date', 'D');
addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');
addUnitAlias('dayOfYear', 'DDD');
addUnitAlias('hour', 'h');
addUnitAlias('minute', 'm');
addUnitAlias('second', 's');
addUnitAlias('millisecond', 'ms');

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function setMonth(date, month) {
    const dayOfMonth = Math.min(date.getDate(), daysInMonth(date.getFullYear(), month));
    date.setMonth(month, dayOfMonth);
}

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

function setDayOfWeek(date, input) {
    const day = date.getDay();
    date.setDate(date.getDate() + input - day);
}

function Duration(duration) {
    var years = duration.year || 0,
        quarters = duration.quarter || 0,
        months = duration.month || 0,
        weeks = duration.week || 0,
        days = duration.day || 0,
        hours = duration.hour || 0,
        minutes = duration.minute || 0,
        seconds = duration.second || 0,
        milliseconds = duration.millisecond || 0;

    // representation for dateAddRemove
    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
    minutes * 6e4 + // 1000 * 60
    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days + weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months + quarters * 3 + years * 12;
}

function createDuration(input, key) {
    const duration = {};
    if (key) {
        duration[normalizeUnits(key)] = input;
    } else {
        duration.millisecond = input;
    }

    return new Duration(duration);
}

function absRound(number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

function createAdder(direction) {
    return function (date, val, period) {
        const duration = createDuration(val, period);
        return addSubtract(date, duration, direction);
    };
}

function addSubtract(original, duration, isAdding) {
    const date = new Date(original.valueOf());
    const milliseconds = duration._milliseconds;
    const days = absRound(duration._days);
    const months = absRound(duration._months);

    if (milliseconds) {
        date.setTime(date.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        date.setDate(date.getDate() + days * isAdding);
        //set(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(date, date.getMonth() + months * isAdding);
    }
    return date;
}

const add = createAdder(1);
const subtract = createAdder(-1);

function startOf(date, units) {
    units = normalizeUnits(units);
    const modified = new Date(date.valueOf());
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            setMonth(modified, 0);
        /* falls through */
        case 'quarter':
        case 'month':
            modified.setDate(1);
        /* falls through */
        case 'week':
        case 'day':
        case 'date':
            modified.setHours(0);
        /* falls through */
        case 'hour':
            modified.setMinutes(0);
        /* falls through */
        case 'minute':
            modified.setSeconds(0);
        /* falls through */
        case 'second':
            modified.setMilliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        setDayOfWeek(modified, 1);
    }

    // quarters are also special
    if (units === 'quarter') {
        setMonth(modified, Math.floor(modified.getMonth() / 3) * 3);
    }

    return modified;
}

function endOf(date, units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return new Date(date.valueOf());
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    let modified = startOf(date, units);
    modified = add(modified, 1, units);
    modified = subtract(modified, 1, 'ms');
    return modified;
}

function isAfter(first, second, units) {
    if (!isValidDate(first) || !isValidDate(second)) {
        throw new Error('Invalid date');
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return first > second;
    } else {
        return second.valueOf() < startOf(first, units).valueOf();
    }
}

function isBefore(first, second, units) {
    if (!isValidDate(first) || !isValidDate(second)) {
        throw new Error('Invalid date');
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return first < second;
    } else {
        return endOf(first, units).valueOf() < second.valueOf();
    }
}

function isBetween(date, from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? isAfter(date, from, units) : !isBefore(date, from, units)) && (inclusivity[1] === ')' ? isBefore(date, to, units) : !isAfter(date, to, units));
}

function isSame(date, input, units) {
    if (!isValidDate(date) || !isValidDate(input)) {
        throw new Error('Invalid date');
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return date.getTime() === input.getTime();
    } else {
        const inputMs = input.valueOf();
        return startOf(date, units).valueOf() <= inputMs && inputMs <= endOf(date, units).valueOf();
    }
}

function isSameOrAfter(date, input, units) {
    return isSame(date, input, units) || isAfter(date, input, units);
}

function isSameOrBefore(date, input, units) {
    return isSame(date, input, units) || isBefore(date, input, units);
}

function pickBy(fn, moments) {
    var res, i;
    if (!moments.length) {
        return new Date();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!isValidDate(moments[i])) {
            throw new Error('Invalid date');
        } else if (fn(moments[i], res)) {
            res = moments[i];
        }
    }
    return res;
}

function min() {
    for (var _len = arguments.length, dates = Array(_len), _key = 0; _key < _len; _key++) {
        dates[_key] = arguments[_key];
    }

    return pickBy(isBefore, dates);
}

function max() {
    for (var _len2 = arguments.length, dates = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        dates[_key2] = arguments[_key2];
    }

    return pickBy(isAfter, dates);
}

function diff(first, second, units, asFloat) {
    let output;
    if (!isValidDate(first) || !isValidDate(second)) {
        throw new Error('Invalid date');
    }

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(first, second);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        const delta = first - second;
        output = units === 'second' ? delta / 1e3 : // 1000
        units === 'minute' ? delta / 6e4 : // 1000 * 60
        units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
        units === 'day' ? delta / 864e5 : // 1000 * 60 * 60 * 24, negate dst
        units === 'week' ? delta / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
        delta;
    }
    return asFloat ? output : absFloor(output);
}

function absFloor(number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function monthDiff(a, b) {
    // difference in months
    var wholeMonthDiff = (b.getFullYear() - a.getFullYear()) * 12 + (b.getMonth() - a.getMonth()),

    // b is in (anchor - 1 month, anchor + 1 month)
    anchor = add(a, wholeMonthDiff, 'months'),
        anchor2,
        adjust;

    if (b - anchor < 0) {
        anchor2 = add(a, wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = add(a, wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

exports.min = min;
exports.max = max;
exports.isAfter = isAfter;
exports.isBefore = isBefore;
exports.isBetween = isBetween;
exports.isSame = isSame;
exports.isSameOrAfter = isSameOrAfter;
exports.isSameOrBefore = isSameOrBefore;
exports.add = add;
exports.subtract = subtract;
exports.startOf = startOf;
exports.endOf = endOf;
exports.diff = diff;
